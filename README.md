sokoban-planner
===============
A C++ algorithm to provide automatic solutions for sokoban game

The C++ planner aims at exploring another way to represent the Sokoban problem, trying to avoid deadlock detection. It is faster than the PDDL planners.
The basic idea is to start from the final state of a puzzle (the destination block), and from there works its way back to the initial state. In other words, it transforms a “push” action into a “pull” action. The precondition of a pull action is that the player has a box in front of him, and he has a empty spot behind him. By considering a plan as a sequence of “pull” actions from the target destination to its initial state, the box will never in a state of deadlock. This representation avoids the time consuming process of checking deadlocks.
The searching algorithm is also based on Breadth First Search. The player will first check if there’s a box in front of him, and if that box is “pullable”, for one direction. If there’s no box in front of him, he will check if he can move one step in that direction. The strategy for moving multiple boxes is that whenever there is a box in front of the player, he will go check if it is pullable, regardless of box labels.
As to the sequence of four directions for checking, I’m kind of inspired by bug algorithm in motion planning. So a strategy is applied here. Each time after a temp map is pulled out of the queue, the player first looks for the nearest box position, regardless of the obstacles along the path, and roughly calculates in which direction he should move towards that box. That direction will have higher priority for checking that action can be made. After the player has a box besides him, he will also look for the nearest initial box position (because he’s pulling the box), and calculate the prior direction that he should turn into. This may enable the player finding a path more quickly, since he intentionally goes towards the direction of the initial state. But it can also be tricky. The worst case can be that the player’s prior direction is never the true direction. In this case, random or unsorted directions will work better.
The UI is implemented using JUCE. It is for visualizing the plan, see if there are unnecessary moves, and also for fun. Welcome to use our GUI and play with it!
